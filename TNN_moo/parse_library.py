"""
This module provides functions to parse various metrics from circuit files generated by DCshell synthesis.
It creates two gzipped pickle dataframes containing the parameters of the circuits.
Functions:
    parse_area(circ): Parses the total cell area from a given circuit file.
    parse_power(circ): Parses the total power consumption from a given circuit file.
    parse_timing(circ): Parses the data arrival time from a given circuit file.
    parse_eval_mbstc(circ): Parses evaluation metrics for MBSTC circuits from a given circuit file.
    parse_eval_popcount(circ): Parses evaluation metrics for popcount circuits from a given circuit file.
Main Execution:
    Reads all the circuits and parses the area, power, timing, and evaluation metrics for MBSTC and popcount circuits.
    Saves the parsed data into two gzipped pickle dataframes: "AxLibrary/mbstc3b.pkl.gz" and "AxLibrary/popcount.pkl.gz".
"""
#%%
import pandas as pd
import numpy as np
import re
import glob
import os

# %%
def parse_area(circ):
    circ = re.sub(r"\.cgp$", ".dc.area", circ)
    if not os.path.exists(circ):
        return np.nan
    c = open(circ).read()
    area = re.search(r"Total cell area:\s+(\d+\.?\d*)", c).group(1)
    return float(area)

def parse_power(circ):
    circ = re.sub(r"\.cgp$", ".dc.power", circ)
    if not os.path.exists(circ):
        return np.nan
    power = np.nan
    for line in open(circ):
        if g:=re.match(r"Total\s+.*\s+(\d+\.?\d*e?[+-]?\d*)\s*mW\s*$", line):
            power = g.group(1)
    return float(power)
    

def parse_timing(circ):
    circ = re.sub(r"\.cgp$", ".dc.timing", circ)
    if not os.path.exists(circ):
        return np.nan
    c = open(circ).read()
    if "No paths." in c:
        return 0
    
    timing = re.search(r"data arrival time\s+(\d+\.?\d*)", c).group(1)
    return float(timing)

def parse_eval_mbstc(circ):
    circ = re.sub(r"\.cgp$", ".eval", circ)
    if not os.path.exists(circ):
        return np.nan
    c = open(circ).read()
    
    ret = {"mae" : np.nan, "wce" : np.nan, "ep": np.nan}
    try:
        ret["mae"] = float(re.search(r"Core 1 mae: (\d+\.?\d*)", c).group(1))
        ret["wce"] = float(re.search(r"Core 1 wc: (\d+\.?\d*)", c).group(1))
        ret["ep"] = float(re.search(r"EP: (\d+\.?\d*)", c).group(1))
        ret["emae"] = float(re.search(r"Core 1 emae: (.*)", c).group(1))

        ret["est_area_nodes"] = int(re.search(r"Area \(nodes\): (\d+\.?\d*)", c).group(1))
        ret["est_area_pdk45"] = float(re.search(r"Area \(pdk45\): (\d+\.?\d*)", c).group(1))
        ret["est_area_egfet"] = float(re.search(r"Area \(egfet\): (\d+\.?\d*)", c).group(1))
        #Core 1 emae: -nan
# finished at 0.00041
#Area (nodes): 60
#Area (pdk45): 168.479
#Area (egfet): 354.593

    except:
        print("Problem in", circ)
    return ret

def parse_eval_popcount(circ):
    circ = re.sub(r"\.cgp$", ".eval", circ)
    if not os.path.exists(circ):
        return np.nan
    c = open(circ).read()
    
    ret = {"mae" : np.nan, "wce" : np.nan, "ep": np.nan}
    try:
        ret["mae"] = float(re.search(r"Core 1 mae: (\d+\.?\d*)", c).group(1))
        ret["wce"] = float(re.search(r"Core 1 wc: (\d+\.?\d*)", c).group(1))
        ret["ep"] = float(re.search(r"EP: (\d+\.?\d*)", c).group(1))
    except:
        print("Problem in", circ)
    return ret


if __name__ == "__main__":
    #%%
    # Read all the circuits and parse the area, power, timing, and evaluation metrics
    # for MBSTC circuits
    from tqdm.auto import tqdm
    allcirc = []
    for f in tqdm(glob.glob("AxLibrary/*3b_*_mbstc/*/*.cgp", recursive=True)):
        #print(f)
        circ = {}
        circ["circuit"] = f
        g = re.match(r".*\/(.*)_(mbst?c)\/(e?[mwe][acp][e]?)_([^\/]+)\/r.*", f)
        circ["neuron"] = g.group(1)
        circ["architecture"] =g.group(2)
        circ["limit_metric"] = g.group(3)
        circ["limit_str"] = g.group(4)
        circ["limit_val"] = float(g.group(4))
        circ["egfet_area"] = parse_area(f)
        circ["egfet_pwr"] = parse_power(f)
        circ["egfet_delay"] = parse_timing(f)

        circ.update(**parse_eval_mbstc(f))

        #print(circ)
        allcirc.append(circ)

    # %%
    pd.DataFrame(allcirc).to_pickle("AxLibrary/mbstc3b.pkl.gz")
    # %%
    # Same for popcount circuits
    allcirc = []
    for f in tqdm(glob.glob("AxLibrary/popcount_*/*/*.cgp", recursive=True)):
        #print(f)
        circ = {}
        circ["circuit"] = f
        g = re.match(r".*\/popcount_(\d+)\/([mw][ac][e])_([^\/]+)\/r.*", f)
        circ["bw"] = int(g.group(1))
        circ["limit_metric"] = g.group(2)
        circ["limit_str"] = g.group(3)
        circ["limit_val"] = float(g.group(3))
        circ["egfet_area"] = parse_area(f)
        circ["egfet_pwr"] = parse_power(f)
        circ["egfet_delay"] = parse_timing(f)

        circ.update(**parse_eval_popcount(f))

        allcirc.append(circ)

    # %%
    pd.DataFrame(allcirc).to_pickle("AxLibrary/popcount.pkl.gz")
    # %%
